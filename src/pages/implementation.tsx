import Navigation from "~/components/navigation"
import Footer from "~/components/footer"

import { ShowImplementation } from "~/components/implItems"
import { CuteLink, FuddBrand, FuddEco, FuddleBrand, PreviousPage } from "~/components/styling"

export default function ImplementationPage() {
  return (<>
    <Navigation currentItem={"IMPLEMENTATION"} isLogged={false} />
    <div className="py-8 flex justify-center flex-col text-black dark:text-white">
      <h1 className="mt-4 text-4xl font-bold text-center">IMPLEMENTING FUDD</h1>
      <section className="max-w-screen-xl px-10 py-8 md:px-15 lg:px-20 text-lg">
        <h1 className="text-3xl py-4 text-primary-700 dark:text-primary-400">Objectives</h1>
        <p>
          The <FuddEco /> is for implementing web applications. It is made of:
        </p>
        <ul className="ml-4 mt-2 max-w-lg space-y-1 text-black list-disc list-inside dark:text-white">
          <li>a <CuteLink href="/concepts">vision</CuteLink> to drive the selection of components and development processes,</li>
          <li>a <CuteLink href="https://discord.com/whatsupfudd">community</CuteLink></li>
          <li>tutorials</li>
          <li>documentation</li>
          <li>some programming languages</li>
          <li>IDEs</li>
          <li>interpreters, compilers, debuggers</li>
          <li>runtime models</li>
          <li><i>Web</i> frameworks</li>
          <li>packages, versioning and repositories.</li>
        </ul>
        <h1 className="text-3xl pt-10 pb-4 text-primary-700 dark:text-primary-400">Selection criteria</h1>
        <p className="mt-5">
          Based on the vision for an ecosystem that cathers to the needs of web developers as we move into a world where
          spatial computing and powerful AI services become mainstream, we have made some initial decisions on what
          makes up the significant components of <FuddBrand />.
        </p>
        <h2 className="text-2xl mt-6 text-primary-700 dark:text-primary-400">Programming Languages</h2>
        <p className="mt-5">
          First, the elephant in the room: what kind of programming language should we use? We don&apos;t expect that
          developers that will be using <FuddBrand /> will be intimidated by the more complex languages that provide
          type safety, distributed execution, advanced logical concepts and so on. We also want to work in a context that is
          logically efficient, where different kind of programming situations can be tackled by the most appropriate syntax and/or
          programming model. We want to have both the performance of compiled code and the simple and immediate feedback
          of interpreted code usable as required. Finally we want a great mix of maturity and ongoing innovation, giving us
          both a solid base to rely on and access to new features that respond to the trends of the industry.
        </p>
        <p className="mt-5">
          Given that Javascript is a fundamental component of the web applications, it must be part of the equation. However
          Javascript is too simplistic and error-prone to deliver the main features of <FuddBrand />. So we&apos;ll consider Javascript as the
          low-level component of our ecosystem, ie we&apos;ll think of it as the assembly language of the web and use more advanced
          languages to generate it.
        </p>
        <p className="mt-5">
          After a long deliberation, we have decided to use Haskell as the core language for <FuddBrand />. On the positive side,
          Haskell has gone through decades of reflection and improvement in the lab before hitting the mainstream, providing a very
          strong foundation for handling complex logic and data manipulation. It has the best type system in the industry, which
          provides a lot of information for automatic tools and AI aided code generation validation. Haskell is
          extensible in many ways, supporting domain-specific syntax that respond to the desire to use the most efficient expression
          of logic. The code generated by the GHC compiler is efficient and enables many different strategies for optimization,
          memory management and distributed execution. Powerful libraries for modern web application development are mature.
          Finally Haskell can run both in interpreted and compiled mode, and can be transpiled into Javascript to fit in the web
          environment.
        </p>
        <p className="mt-5">
          On the negative side, Haskell is a legendary but yet relatively unknown language. Given its large amount of features and
          its stronly functional
          programming features, developers that don&apos;t have a good background in computer science have a harder time using
          it. The large amount of people involved in the research sector that use Haskell means there are many powerful and advanced
          libraries available, but many aren&apos;t
          well documented and require serious reflection to extend and improve. As Haskell is in very active development,
          keeping up with the latest features and best practices is a challenge. The long gestation period of Haskell in the
          academic circles has given it a reputation for not being practical in the real world. Finally the presence of a myriad of advanced
          theoretical computer science concepts that are easily accessible in Haskell can be a distraction or a source of confusion
          for the developers when they are browsing the ecosystem (discussions about <i>monads</i> being the most typical example of that).
        </p>
        <p className="mt-5">
          To ease the shock of having Haskell as the core language, we developped <FuddleBrand />, a fork of the Elm language that provides a
          simpler and more immediate scripting solution that can also ease the discovery of functional programming. Elm
          is already a very good language that gets compiled into efficient Javascript and that is especially powerful for
          client-side development, inspiring many of the current trends in web development. Unfortunately it has lost its way
          in the last few years and the development of the core components has stalled. Fuddle will keep the simplicity of Elm, but we&apos;ll improve its client-side DOM management system, open it
          to the rest of the Javascript world, add more support for server-side utilization, and make the packaging and deployment
          of web applications more flexible.
        </p>
        <h2 className="text-2xl mt-6 text-primary-700 dark:text-primary-400">Web frameworks</h2>
        <p className="mt-5">
          Is it suicidal to base <FuddBrand /> on Haskell and Elm if the world runs out of React and NextJS? Yes, unless we can
          do 3 important things:
        </p>
        <ul className="mt-5 list-disc pl-5">
          <li>provide the features that have made React and NextJS so popular: components, html-and-logic blending (JSX),
            implicit routing from directories and files, simple build and rapid code-view cycles</li>
          <li>recycle existings projects and automatize the transition</li>
          <li>get developers to achieve significantly more impressive results</li>
        </ul>
        <p className="mt-5">
          Then hopefully we can get momentum and build a community that will deliver significant momentum acceleration to the industry.
        </p>
        <p className="mt-5">
          Elm and Haskell provide without a doubt the fire power to deliver on the third point. Elm is html-and-logic blending at its
          finest, it is a real functional approach to components (React started in Standard ML but eventually downgraded to Javascript),
          the compiler is super fast and it has built-in code-view cycles and embedded debugging. Beyond that, <FuddBrand /> needs
          to create value.
        </p>
        <p className="mt-5">
          The basis for <FuddBrand /> winning over the React and NextJS developers is its <b>Daniell</b> website builder. For a start,&nbsp;
          <b>Daniell</b> will support the Hugo, Gatsby and NextJS structures and generates a ready-to-run website super fast. As expected
          it provides a live server, with much faster hot reload than NextJS and Gatsby. But it also follows the Phoenix approach and
          provides a built-in IDE for
          easier project and resource management, as well as an introspection UI for faster issue resolution. <b>Daniell</b> brings in
          additional innovation with the possibility to use Fuddle as the scripting system for the server-side render. Together with
          the client-side DOM management of Fuddle, the end result is a much more flexible and powerful web framework than React and the
          hydration approach of NextJS closer to the Pheonix/LiveView and Htmx frameworks. <b>Daniell</b> interacts with AI aided coding
          to speed up the implementation of a website by integrating automatic content, layout and translation generation from short descriptions.
        </p>
        <p className="mt-5">
          To speedup the development of web applications, <b>Daniell</b> comes with builtin support for the <i>Tailwind CSS</i> styling
          package and the <i>Flowbite</i> UI block code library. It facilitates and speeds up the creation of a modern and responsive
          user interface without complicated UI components, and analyze CSS rules to help debug visual errors.
        </p>
        <p className="mt-5">
          When it comes to deploying a web application in production, an optimized runtime of <b>Daniell</b> based on the <i>Servant</i>&nbsp;
          framework comes in the picture. This runtime is extremely performant, secure and scalable due to its distributed computing
          design. It is also extensible to support a wide range of web application requirements.
        </p>
        <p className="mt-5">
          But Hugo, Gatsby and NextJS are only used for a minorty of the websites in the world; the real player is Wordpress... So <FuddBrand />
          brings the <b>EasyWordy</b> project to create a drop-in replacement of the PHP-based Wordpress that is much more secure and performant,
          and open up the door to a smooth evolution of Wordpress sites to more advanced technology. The <b>EasyWordy</b> server uses a Haskell version
          of Wordpress logic and API, and cooperates with an integrated PHP engine to run existing plugins and themes. But the idea is not
          to do more PHP code, and <b>EasyWordy</b> integrates with <b>Daniell</b> to smoothly migrate websites over time to more secure
          and powerful technologies.
        </p>
        <p className="mt-5">
          The <b>VSocMed</b> project will provide a way to generate a static website from a short description, and to manage the
          community that is interested in the website. The <b>Migrator</b> project will provide a way to migrate a SQL database from
          one version to another, and to generate the migration code that is required to do so.
        </p>
        <h2 className="text-2xl mt-6 text-primary-700 dark:text-primary-400">Community</h2>
        <p className="mt-5">
          With this out of the way, let&apos;s jump to the development of the community. The <FuddBrand /> project is ambitious and
          as such will require the help of many great people. The <FuddBrand /> community must be welcoming, inclusive, foster
          creativity and innovation, efficient and operate with a high level of transparency. Previous experience in community
          building and large open-source projects have shown that we must establish a strong leadership but make sure that
          the strenght isn&apos;t concentrated in a few individuals. The basis for directing the future of the community will be
          frequent referendum and a management system that is based on merit and contribution.
        </p>
        <h2 className="text-2xl mt-6 text-primary-700 dark:text-primary-400">Tutorial</h2>
        <p className="mt-5">
          To achieve an efficient and self-improving distribution of all knowledge about the <FuddEco />, we&apos;ll use Jupyter Notebook
          as the basis for creating tutorials and examples. To that end we&apos;ll expand the Jupyter&apos;s IHaskell kernel to include more
          flexibility in package access, and we&apos;ll set up a much simpler multi-user environment for Jupyter Notebooks than JupyterHub
          on Kubernetes.
        </p>
        <h2 className="text-2xl mt-6 text-primary-700 dark:text-primary-400">Documentation</h2>
        <p className="mt-5">
          Applying the <FuddBrand /> vision to the development of its documentation, we&apos;ll use dynamic multi-media documents to
          maximise the learning experience and the quantity of information that can be shared. Generative AI will be applied to
          create as much reference material as possible, and the community will be continuously pulsed on the quality and relevance
          of the available documentation, as well as the areas that require more content.
        </p>
        <h2 className="text-2xl mt-6 text-primary-700 dark:text-primary-400">IDEs</h2>
        <p className="mt-5">
          The <FuddEco /> will expect developers to work on VC Code and NeoVim, and we&apos;ll make sure that there are
          good plugins and extensions for these two IDEs. We&apos;ll also provide a web-based IDE integrated with
          the Web frameworks, AI-aided coding and language servers that can create a better multi-media experience
          than VS Code and NeoVim can.
        </p>
        <h2 className="text-2xl mt-6 text-primary-700 dark:text-primary-400">Interpreters, compilers, debuggers</h2>
        <p className="mt-5">
          We use the Glasgow Haskell framework (GHC), which already provides an advanced compiler, interpreter and debugger.
          We&apos;ll contribute to the GHC by integrating project management and build process more tightly into the IDEs,
          and adding an build intermediate storage for significantly speeding up the compilation speed and the power of
          the language server. We&apos;ll add a layer to the error message generator to make it more user-friendly and facilitate
          the understanding of complicated errors. We&apos;ll expand the garbage collector to provide memory serialization
          similar to the Smalltalk and use that for enhancing the debugger and accelerating the iterative compilation cycles.
          Finally we&apos;ll contribute to the documentation to make sure that all features and possibilities of GHC are easily
          accessible and thoroughly explained.
        </p>
        <p className="mt-5">
          Fuddle, our fork of Elm, will add more flexibility to the package resolution logic to provide multiple sources
          of repositories to access modules from. It will also unify the Haskell syntax for type and array notation to
          simplify the recycling of Fuddle code in Haskell and vice-versa for simpler elements of Haskell. Fuddle will
          have a foreign-function interface that simplify the reutilisation of Javascript code rather than relying solely
          on ports. We also will provide a intermediate compilation representation to support type-safe adhoc module
          interfacing at runtime.
          We&apos;ll also add the necessary features to the compiler to work as a language server instead of having a third-party
          solution for that.
          We&apos;ll expand the debugging capabilities of Elm to work in server-side execution and connect to IDEs.
        </p>
        <h2 className="text-2xl mt-6 text-primary-700 dark:text-primary-400">Runtime models</h2>
        <p className="mt-5">
          There are already many poweful features in the GHC runtime environment, such as distributed execution,
          multiple garbage collection strategies, and a broad range of profiling elements. We&apos;ll provide an integration
          of all these features into the IDEs to easily control and inspect the behavior of live applications.
        </p>
        <p className="mt-5">
          An important innovation in the Fuddle runtime vs Elm is a distributed execution model with an inteface concept.
          This removes a severe limitation of Elm vs React: the impossibility to compose <i>adhoc components</i>
          due to having a single top-level MVC loop with a global definition of the state and event system.
          In Fuddle many independant modules that implement small pieces of a UI can interact through multiple MVC loops
          that each manage local states and events without loosing the bug-protection of strong type safety. Another important
          improvement of Fuddle over Elm is the use of more flexible DOM management engine that uses the LiveView and HTMX
          approach to update the browser content. This increases the cooperation between Fuddle and Javascript logic and
          integrates seamlessly server-side content generation. Finally Fuddle runtime gains a proper server-side support for
          scripting on the server (template logic, interpreted logic, REPL operations) rather than web browser.
        </p>
        <h2 className="text-2xl mt-6 text-primary-700 dark:text-primary-400">Packages, versioning and repos</h2>
        <p className="mt-5">
          Haskell and Elm already have a rich set of packages that provide functionality for a wide set of tasks. We
          will help developers with their selection process by maintaining a curated list of packages that
          are especially useful for our target applications, which we enhance the tutorials and documentation for.
          We also provide the community with a feedback system to rate the quality of the packages and their
          completeness vs the general advance technologies in the industry, and from this we derive extension
          plans for relevant packages.
        </p>
        <h1 className="text-2xl pt-10 pb-4 text-primary-700 dark:text-primary-400">Stuff</h1>
        <p className="mt-6">
          The first concept to achieve this goal is go the functional way, reduce the amount of
          syntax and enable embedded specialized extensions for different kind of situations, such as
          SQL for data manipulations, HTML for web, and so on.
        </p>
        <p className="mt-6">
          The second concept is to strike a good balance between not reinventing the wheel, but not
          getting stuck with the status quo either. This means that FUDD builds on powerful and mature
          technologies, and extends them to provide a more advanced and easier to use experience. The
          underlying implications is that the ecosystem will evolve significantly, and finding the right
          balance between incorporating existing solutions and creating new ones is an art that will
          require a strong interaction with the community.
        </p>
        <p className="mt-6">
          The third concept is to take advantage of the AI technologies to offer as much knowledge and
          training material as possible to the developers. The ecosystem must also provide tools to
          generate ample tutorials, examples and reference documents that are up-to-date, interesting and interactive.
        </p>
        <br />
        <br />
        <h1 className="text-3xl pb-4 text-primary-700 dark:text-primary-400">Components</h1>
        <p>
          The FUDD ecosystem core components are evolved from best-of-breed mature technologies. They
          include:
        </p>
        <ul className="mt-5 list-disc pl-5">
          <li>the Elm language as the basis to create UI logic and do scripting,</li>
          <li>the Servant framework (Haskell) for backend web services,</li>
          <li>the Hugo, Gatsby and Next.js folder and file structures for describing websites,</li>
          <li>the Hasql framework (Haskell) for embedded SQL</li>
          <li>the Wordpress CMS structures for describing editable websites,</li>
          <li>the TailwindCSS framework for styling HTML,</li>
          <li>the Jupyter notebook and IHaskell runtime for providing interactive tutorials.</li>
        </ul>
        <ShowImplementation />
      </section>
      <PreviousPage destination={"/concepts"}>Concepts</PreviousPage>
    </div>
    <Footer />
  </>)
}